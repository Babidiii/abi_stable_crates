use abi_stable::{
    nonexhaustive_enum::{
        NonExhaustiveFor,NonExhaustive,DeserializeOwned,GetEnumInfo,InterfaceBound
    },
    library::RootModule,
    sabi_types::{VersionStrings},
    std_types::{RBox,RString,RResult,RStr,RBoxError,RVec},
    type_level::{
        bools::True,
        impl_enum::{Implemented,Unimplemented,IsImplemented},
        trait_marker,
    },
    sabi_trait,
    StableAbi,InterfaceType,
    package_version_strings,
    declare_root_module_statics,
    impl_InterfaceType,
};

#[cfg(feature="v1_1")]
use serde::{Deserialize,Deserializer};

use serde_json::value::RawValue;


#[repr(transparent)]
#[cfg_attr(feature="v1_1",derive(Deserialize))]
#[derive(StableAbi,Debug,Clone,Copy,PartialEq)]
pub struct Cents{
    pub cents:u64,
}

#[repr(transparent)]
#[cfg_attr(feature="v1_1",derive(Deserialize))]
#[derive(StableAbi,Debug,Clone,Copy,PartialEq)]
pub struct ItemId{
    #[doc(hidden)]
    pub id:usize,
}


///////////////////////////////////////////////////////////////////////////////


#[repr(transparent)]
#[cfg(feature="v1_1")]
#[derive(StableAbi,Debug,Clone,PartialEq)]
pub struct SerdeWrapper<T>{
    pub inner:T,
}

#[cfg(feature="v1_1")]
impl<T> SerdeWrapper<T>{
    pub fn new(inner:T)->Self{
        Self{inner}
    }
}


#[cfg(feature="v1_1")]
impl<'de,T> Deserialize<'de> for SerdeWrapper<NonExhaustiveFor<T>>
where
    T: GetEnumInfo+'de,
    T::DefaultInterface: DeserializeOwned<T,T::DefaultStorage,T::DefaultInterface>,
    T::DefaultInterface: InterfaceBound<Deserialize=Implemented<trait_marker::Deserialize>>,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = <&RawValue>::deserialize(deserializer)?;
        NonExhaustiveFor::<T>::deserialize_owned_from_str(s.get())
            .map(|x| SerdeWrapper{inner:x} )
            .map_err(serde::de::Error::custom)
    }
}


///////////////////////////////////////////////////////////////////////////////


#[repr(u8)]
#[cfg_attr(feature="v1_1",derive(Deserialize))]
#[derive(StableAbi,Debug,Clone,PartialEq)]
#[sabi(kind(WithNonExhaustive(
    size="[usize;8]",
    traits(Send,Sync,Debug,Clone,PartialEq,Deserialize),
    assert_nonexhaustive="Command",
)))]
pub enum Command{
    #[doc(hidden)]
    #[sabi(with_constructor)]
    __NonExhaustive,
    #[sabi(with_boxed_constructor)]
    CreateItem(RBox<ParamCreateItem>),
    DeleteItem{
        id:ItemId,
    },
    AddItem{
        id:ItemId,
        count:u32,
    },
    RemoveItem{
        id:ItemId,
        count:u32,
    },
    #[cfg(feature="v1_1")]
    RenameItem{
        id:ItemId,
        new_name:RString,
    },
    #[cfg(feature="v1_1")]
    #[sabi(with_constructor)]
    Many{
        list:RVec<SerdeWrapper<Command_NE>>
    },
}


/*
//This was generated by the StableAbi derive macro on Command.
pub type Command_NE=
    NonExhaustive<
        Command,
        Command_Storage,
        Command_Interface,
    >;
*/

#[repr(C)]
#[cfg_attr(feature="v1_1",derive(Deserialize))]
#[derive(StableAbi,Debug,Clone,PartialEq)]
pub struct ParamCreateItem{
    pub name:RString,
    pub initial_count:u32,
    pub price:Cents,
}

impl DeserializeOwned<Command,Command_Storage,Command_Interface> for Command_Interface{
    fn deserialize_enum(s: RStr<'_>) -> Result<Command_NE, RBoxError>{
        ShopMod::get_module().unwrap().deserialize_command()(s).into_result()
    }
}


#[test]
#[cfg(feature="v1_1")]
fn examples_of_constructing_a_Command(){
    let id=ItemId{id:0};


    // Constructing a Command::CreateItem wrapped in NonExhaustive
    // using the constructor generated by using #[sabi(with_boxed_constructor)] on the variant.
    assert_eq!(
        Command::CreateItem_NE(ParamCreateItem{
            name:"foo".into(),
            initial_count:1,
            price:Cents{cents:1},
        }), 
        {
            let x=ParamCreateItem{
                name:"foo".into(),
                initial_count:1,
                price:Cents{cents:1},
            };
            let x=RBox::new(x);
            let x=Command::CreateItem(x);
            NonExhaustive::new(x)
        }
    );
    
    // Constructing a Command::RemoveItem wrapped in NonExhaustive 
    // without using the constructors generated using 
    // either #[sabi(with_constructor)] or #[sabi(with_boxed_constructor)],
    // since neither attribute was applied to the enum or the variant.
    {
        let x=Command::RemoveItem{id,count:1};
        let _=NonExhaustive::new(x);
    }

    // Constructing a Command::Many wrapped in NonExhaustive
    // using the constructor genereated by using #[sabi(with_constructor)] on the variant
    assert_eq!(
        Command::Many_NE(RVec::new()),
        {
            let x=Command::Many{list:RVec::new()};
            NonExhaustive::new(x)
        }
    );
}


///////////////////////////////////////////////////////////////////////////////


#[repr(u8)]
#[cfg_attr(feature="v1_1",derive(Deserialize))]
#[derive(StableAbi,Debug,Clone,PartialEq)]
#[sabi(kind(WithNonExhaustive(
    size="[usize;6]",
    interface="Command_Interface",
    assert_nonexhaustive="ReturnVal",
)))]
pub enum ReturnVal{
    #[doc(hidden)]
    __NonExhaustive,
    CreateItem{
        count:u32,
        id:ItemId,
    },
    DeleteItem{
        id:ItemId,
    },
    AddItem{
        remaining:u32,
        id:ItemId,
    },
    RemoveItem{
        removed:u32,
        remaining:u32,
        id:ItemId,
    },
    #[cfg(feature="v1_1")]
    #[sabi(with_boxed_constructor)]
    RenameItem(RBox<RetRenameItem>),

    #[cfg(feature="v1_1")]
    #[sabi(with_constructor)]
    Many{
        list:RVec<SerdeWrapper<ReturnVal_NE>>
    },
}

/*
//This was generated by the StableAbi derive macro on ReturnVal.
pub type ReturnVal_NE=
    NonExhaustive<
        ReturnVal,
        ReturnVal_Storage,
        Command_Interface,
    >;
*/

#[cfg(feature="v1_1")]
#[repr(C)]
#[derive(StableAbi,Debug,Clone,PartialEq,Deserialize)]
pub struct RetRenameItem{
    pub id:ItemId,
    pub new_name:RString,
    pub old_name:RString,
}

impl DeserializeOwned<ReturnVal,ReturnVal_Storage,Command_Interface> for Command_Interface{
    fn deserialize_enum(s: RStr<'_>) -> Result<ReturnVal_NE, RBoxError>{
        ShopMod::get_module().unwrap().deserialize_ret_val()(s).into_result()
    }
}


#[test]
#[cfg(feature="v1_1")]
fn examples_of_constructing_a_ReturnVal(){
    let id=ItemId{id:0};

    // Constructing a ReturnVal::RemoveItem wrapped in NonExhaustive 
    // without using the constructors generated using 
    // either #[sabi(with_constructor)] or #[sabi(with_boxed_constructor)],
    // since neither attribute was applied to the enum or the variant.
    {
        let x=ReturnVal::RemoveItem{removed:0,remaining:0,id};
        let _=NonExhaustive::new(x);
    }

    // Constructing a ReturnVal::RenameItem wrapped in NonExhaustive
    // using the constructor generated by using #[sabi(with_boxed_constructor)] on the variant
    assert_eq!(
        ReturnVal::RenameItem_NE(RetRenameItem{
            id,
            new_name:"foo".into(),
            old_name:"bar".into(),
        }), 
        {
            let x=RetRenameItem{
                id,
                new_name:"foo".into(),
                old_name:"bar".into(),
            };
            let x=RBox::new(x);
            let x=ReturnVal::RenameItem(x);
            NonExhaustive::new(x)
        }
    );
    
    // Constructing a ReturnVal::Many wrapped in NonExhaustive
    // using the constructor genereated by using #[sabi(with_constructor)] on the variant
    assert_eq!(
        ReturnVal::Many_NE(RVec::new()),
        {
            let x=ReturnVal::Many{list:RVec::new()};
            NonExhaustive::new(x)
        }
    );
}


///////////////////////////////////////////////////////////////////////////////


#[repr(u8)]
#[derive(StableAbi,Debug,Clone,PartialEq)]
#[sabi(kind(WithNonExhaustive(
    size="[usize;6]",
    traits(Send,Sync,Debug,Clone,PartialEq),
)))]
#[sabi(with_constructor)]
pub enum Error{
    #[doc(hidden)]
    __NonExhaustive,
    ItemAlreadyExists{
        id:ItemId,
        name:RString,
    },
    ItemIdNotFound{
        id:ItemId,
    },
    #[sabi(with_boxed_constructor)]
    InvalidCommand{
        cmd:RBox<Command_NE>,
    },
}

// Because Error has the `#[sabi(with_constructor)]` attribute applied to it,
// StableAbi generates constructor functions for each variant.
// InvalidCommand overrides it with `#[sabi(with_boxed_constructor)]`,
// which generates constructor functions for variants which wrap a pointer.
#[test]
#[cfg(feature="v1_1")]
fn examples_of_constructing_an_Error(){
    let id=ItemId{id:0};

    assert_eq!(
        Error::ItemAlreadyExists_NE(id,"hello".into()),
        {
            let x=Error::ItemAlreadyExists{id,name:"hello".into()};
            NonExhaustive::new(x)
        }
    );

    assert_eq!(
        Error::ItemIdNotFound_NE(id),
        {
            let x=Error::ItemIdNotFound{id};
            NonExhaustive::new(x)
        }
    );

    assert_eq!(
        Error::InvalidCommand_NE(Command::__NonExhaustive_NE()),
        {
            let x=Command::__NonExhaustive;
            let x=NonExhaustive::new(x);
            let x=RBox::new(x);
            let x=Error::InvalidCommand{cmd:x};
            NonExhaustive::new(x)
        }
    );
}


#[repr(C)]
#[derive(StableAbi)] 
#[sabi(kind(Prefix(prefix_struct="ShopMod")))]
#[sabi(missing_field(panic))]
pub struct ShopModVal {
    pub new:extern "C" fn()->Shop_TO<'static,RBox<()>>,

    pub deserialize_command:
        extern "C" fn(s:RStr<'_>)->RResult<Command_NE,RBoxError>,

    #[sabi(last_prefix_field)]
    pub deserialize_ret_val:
        extern "C" fn(s:RStr<'_>)->RResult<ReturnVal_NE,RBoxError>,
}


impl RootModule for ShopMod {
    declare_root_module_statics!{ShopMod}
    const BASE_NAME: &'static str = "shop";
    const NAME: &'static str = "shop";
    const VERSION_STRINGS: VersionStrings = package_version_strings!();
}



#[sabi_trait]
pub trait Shop{
    #[sabi(last_prefix_field)]
    fn run_command(
        &mut self,
        cmd:Command_NE,
    ) -> RResult<ReturnVal_NE,NonExhaustiveFor<Error>>;
}



