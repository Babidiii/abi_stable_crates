/*!

This attribute generates an ffi-safe trait object on the trait it's applied to.

All items outside the list of generated items comes from `abi_stable::sabi_trait::prelude`.


# Supertraits.

By default these are the supertraits that `#[sabi_trait]` traits can have:

- lifetimes 

- Debug

- Clone

- Send

- Syn

To be able to have more supertraits you must use the `#[sabi(use_dyntrait)]` attribute,
which will allow the supertraits that `DynTrait` can implement.

# Extensibility

`#[sabi_trait]` trait objects are (ABI-wise) safe to extend in minor versions,
so long as methods are always added at the end.

A library will not load (through safe means) if methods are added anywhere but the end.
One can still load the library if they use unsafe code to skip the type checking 
that abi_stable does at load-time.


Accidentally calling newer methods on trait objects from older versions of a
library will cause a panic at runtime.
This is only possible if one loads multiple versions of a library,
where the trait is extended in each version,
and passes trait objects among those libraries.

# Generated items.

These are the items generated by the attribute,
where `Trait` is the name of the annotated trait:

<h3> Trait_from_ptr </h3>

A constructor for the trait object,which takes a pointer to a value that implements the trait.

Generally it is called like this:
`Trait_from_ptr::<_,Erasability, TraitParam0, TraitParam1 >( pointer )`.

Where `Erasability` can be either:

-`TU_Unerasable`:
    Which allows the trait object to be unerased,requires that the value implements any.

.`TU_Opaque`Which does not allow the trait object to be unerased.

Where `TraitParam` are the type parameters of the trait.

<h3> Trait_from_value </h3>

A constructor for the trait object,which takes a value that implements the trait.

This is equivalent to calling `Trait_from_ptr` with `RBox::new(value)`.

<h3> Trait_TO </h3>

The ffi-safe trait object.

<br>

This only implements `Trait` if all the methods are callable,
with these trait bounds for each method:

- `&self`: `Pointer:Deref<Target=()>`.
- `&mut self`: `Pointer:DerefMut<Target=()>`.
- `self`: `Pointer:OwnedPointer<Target=()>`.

<br>

`Trait_Methods` is implemented so long as 
the supertraits are implemented and all where predicates are satisfied.
Only requiring the trait bounds for `Pointer` on each method when they are called.

<br>

Trait_TO has these generic parameters(in order):

- `'trait_lifetime_n`: The lifetime parameters of the trait,if any.

- `'lt`:this is the lifetime of the type that the trait object was construct with.

- `Pointer`: 
    An pointer whose referent has been erased,
    most commonly `RBox<()>`/RArc<()>`/`&()`/`&mut ()`.

- `trait_type_param_n`: The type parameters of the trait.

- `trait_assoc_type_n`: The associated types of the trait.


A trait defined like this:`trait Foo<'a,T,U>{ type Hello; type World; }`,
has this trait object:`Foo_TO<'a,'lt,Pointer,T,U,Hello,World>`.



<h3> Trait </h3>

The trait is defined similarly to how it is before being transformed by the 
`#[sabi_trait]` attribute.

These are the differences:

- If there is a by-value method,a `Self:Sized` constraint will be added automatically.

<h3> Trait_Methods </h3>

This trait is defined similarly to `Trait`,
it is as an extension trait for the underlying implementation of trait objects 
(DynTrait/RObject) so as to define the "inherent" methods of `Trait_TO`.

This trait must be imported wherever the trait object it used.

<h3> Trait_Marker </h3>

A marker type,used to represent the trait in some contexts.


# VTable attributes

To pass attributes to the generated vtable you can use the `#[sabi(  )]` attributes 
that are valid for `#[derive(StableAbi)]`.

[Here is the documentation for the derive macro.
](../stable_abi_derive/index.html)

# Trait attributes.

These are attributes for the generated trait,applied on the trait(not on methods).

<h3> #[sabi(debug_print_trait)] </h3>

Prints the output generated by the attribute macro,

Note that this does not expand the output of the 
`#[derive(StableAbi)]` attribute on the vtable.

<h3> #[sabi(use_dyntrait)] </h3>

Changes how the trait object is implemented to use `DynTrait` instead of `RObject`,
this allows using more traits,with the (potential) cost of having more overhead.

# Associated types

The only valid way to refer to associated types in the trait declaration is with 
`Self::AssocType` syntax.

Associated types in the trait object are transformed into type parameters 
that come before those of the trait.

# Object safety

Trait objects generated using this attribute have similar restrictions to built-in trait objects:

- `Self` can only be used to access associated types 
    (using the `Self::AssocType` syntax).

- `self` is a valid method receiver,
    this requires that the pointer that the generated trait object wraps 
    implements `abi_stable::pointer_trait::OwnedPointer`.

# Examples

<h3> Dictionary trait </h3>

```rust
use abi_stable::{
    StableAbi,
    sabi_trait,
    sabi_trait::prelude::*,
    std_types::{RBox,RArc,RHashMap,RString},
};

#[sabi_trait]
pub trait Dictionary{
    type Value;
    fn get(&self,key:&str)->Option<&Self::Value>;
    fn insert(&mut self,key:RString,value:Self::Value)->Option<Self::Value>;
}


# fn main() {

{
    impl<V> Dictionary for RHashMap<RString,V>{
        type Value=V;
        fn get(&self,key:&str)->Option<&V>{
            self.get(key)
        }
        fn insert(&mut self,key:RString,value:V)->Option<V>{
            self.insert(key,value).into()
        }
    }

    let mut map=RHashMap::<RString,u32>::new();
    map.insert("hello".into(),100);
    map.insert("world".into(),10);

    {
        // This type annotation is for the reader
        //
        // You can unerase trait objects constructed with `TU_Unerasable` 
        // (as opposed to `TU_Opaque`,which can't be unerased).
        let mut object:Dictionary_TO<'_,RBox<()>,u32>=
            Dictionary_from_value::<_,TU_Unerasable>(map.clone());

        assert_eq!(object.get("hello"),Some(&100));
        assert_eq!(Dictionary::get(&object,"hello"),Some(&100));
        
        assert_eq!(object.get_("world"),Some(&10));
        assert_eq!(Dictionary_Methods::get_(&object,"world"),Some(&10));

        object.insert("what".into(),99);

        // You can only unerase a trait object if it was constructed with `TU_Unerasable`
        // and it's being unerased into a type that implements `std::any::Any`.
        let map:RBox<RHashMap<RString,u32>>=object.sabi_into_any_unerased().unwrap();

        assert_eq!(map.get("hello"), Some(&100));
        assert_eq!(map.get("world"), Some(&10));
        assert_eq!(map.get("what"), Some(&99));
    }
    {
        let arc=RArc::new(map.clone());
        // This type annotation is for the reader
        //
        // You can unerase trait objects constructed with `TU_Unerasable` 
        // (as opposed to `TU_Opaque`,which can't be unerased).
        let object:Dictionary_TO<'_,RArc<()>,u32>=
            Dictionary_from_ptr::<_,TU_Unerasable>(arc);

        assert_eq!(object.get_("world"),Some(&10));
        assert_eq!(Dictionary_Methods::get_(&object,"world"),Some(&10));

        
        // Can't call these methods on `Dictionary_TO<RArc<()>,..>`
        // because `RArc<_>` doesn't implement DerefMut.
        //
        // assert_eq!(object.get("hello"),Some(&100));
        // assert_eq!(Dictionary::get(&object,"hello"),Some(&100));
        //
        // object.insert("what".into(),99);
        // Methods::insert(&mut object,"what".into(),99);
        //
        // object.insert_("what".into(),99);
        // Dictionary_Methods::insert_(&mut object,"what".into(),99);
        

        let map:RArc<RHashMap<RString,u32>>=object.sabi_into_any_unerased().unwrap();
        assert_eq!(map.get("hello"), Some(&100));
        assert_eq!(map.get("world"), Some(&10));
    }

}

{
    impl Dictionary for (){
        type Value=RString;
        fn get(&self,_:&str)->Option<&RString>{
            None
        }
        fn insert(&mut self,_:RString,_:RString)->Option<RString>{
            None
        }
    }

    // This type annotation is for the reader
    let object:Dictionary_TO<'_,RBox<()>,RString>=
        Dictionary_from_value::<_,TU_Opaque>( () );

    assert_eq!(object.get("hello"),None);
    assert_eq!(object.get("world"),None);

    // Cannot unerase trait objects created with `TU_Opaque`.
    assert_eq!(object.sabi_into_any_unerased::<()>().ok(),None);
}

# }

```


*/